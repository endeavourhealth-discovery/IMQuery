<template>
  <div :class="'text-definition  ' + [highlighted ? 'highlighted' : '']">
    <!-- Custom Sentences - add new ones here  -->
    <div v-if="template == 'IncludeEntity' && entity" class="horizontal">
      <Keyword> Include</Keyword>
      <Static> a</Static>
      <Selector :path="path" :modelValue="entity" :edit="edit"></Selector>
      <Static> if</Static>
      <Static> they</Static>
    </div>
    <!-- Custom Sentences - add new ones here -->

    <!-- For all sentences generated by backend -->
    <template v-else-if="valueType == 'filter' && entity">
      
      <div v-if="hasKey(entity, 'property')" :class="'property horizontal  relative hover:bg-black hover:bg-opacity-10 rounded-md px-2' + [index > 0 ? ' ' : '']">
        <Keyword v-if="index > 0" :class="'operator-label '"> {{ operator }}</Keyword>
        <Selector v-if="entity" class=" " :path="path" :modelValue="entity" :edit="edit"></Selector>
      </div>

      <template v-else v-for="(child, childIndex) in children(entity)" :key="child.path">
        <div v-if="isOperator(child?.path)" class="operator horizontal hover:bg-black hover:bg-opacity-5 rounded-md p-2 ">
          <Keyword class="operator-label ">{{ showOperator(path, index, childIndex) ? operator : "" }}</Keyword>
          <div class="operator-items">
            <Phrase
              v-for="(grandChild, grandChildIndex) in children(child.value)"
              :object="object"
              :path="`${path}.${child?.path}[${grandChildIndex}]`"
              valueType="filter"
              :operator="grandChildIndex > 0 ? child.path : ''"
              :index="grandChildIndex"
              :edit="edit"
            >
            </Phrase>
          </div>
        </div>
      </template>

    </template>

    <!-- Child phrases -->
    <slot> </slot>
    <!-- Child phrases -->
  </div>
</template>

<script lang="ts">
import { defineComponent } from "vue";
import { Helpers } from "../../models/text/Helpers";

import Static from "./Static.vue";
import Selector from "./Selector.vue";
import Keyword from "./Keyword.vue";
import _ from "lodash";

export default defineComponent({
  name: "Phrase",
  components: { Selector, Static, Keyword },
  props: ["template", "modelValue", "object", "path", "valueType", "keys", "excludedKeys", "operator", "highlighted", "index", "edit"],
  // emits: ["update:modelValue"],
  methods: {
    showOperator(path: string, index: number, childIndex): boolean {
      // console.log("path", path);
      // console.log("index", index);
      if (index > 0 || childIndex > 0) return true;
      return false;
    },
    isOperator(testString: any): boolean {
      return ["and", "or"].includes(testString);
    },
    hasKey(testObjecty: any, comparatorKey: string): boolean {
      return Object.keys(testObjecty).some(key => key == comparatorKey);
    },
    children(testObject: any) {
      // console.log("keys", Object.keys(testObject));
      let children = Object.keys(testObject).map((key: string) => {
        const isIncludedKey = ["and", "or", "property"].includes(key);
        const isExcludedKey = ["entityType"].includes(key);
        const isNumber = typeof parseInt(key) == "number";
        // console.log("hasIncludedKeys", hasIncludedKeys);
        // console.log("hasExcludedKeys", hasExcludedKeys);
        // console.log("parseInt(key)", parseInt(key));
        // console.log("isNumber", isNumber);

        if ((isIncludedKey || isNumber) && !isExcludedKey) {
          return { path: key, value: testObject[key] };
        } else {
          return {};
        }
      });
      children = children.filter(child => child.path);
      return children;
    }
  },
  data() {
    return {
      editMode: this.edit,
      entity: this.path ? _.get(this.object, this.path) : this.object
    };
  },
  computed: {
    pronoun: {
      get() {
        return Helpers.pronoun(this.entity.name);
      },
      set() {}
    },
    a: {
      get() {
        return Helpers.a(this.entity.name);
      },
      set() {}
    }
  },
  watch: {
    edit(newValue: any) {
      this.editMode = this.newValue;
    }
  }
});
</script>

<style>

.definition::-webkit-scrollbar{
  width: 8px;
}
::-webkit-scrollbar-thumb {
  background-color: #94a3b8; 
  border-radius: 20px;
}

.text-definition,
.text-definition .static {
  font-size: 14px !important;
  font-weight: 400 !important;
  color: #000 !important;
}

.phrase {
  display: inline-flex;
}

.text-definition .vertical {
  display: inline-flex;
  flex-direction: column;
}

.text-definition .list,
.text-definition .subset .subphrases {
  display: inline-flex;
  flex-direction: column;
}

.subphrase {
  display: inline-flex;
}

.horizontal {
  display: flex;
}

.horizontal > :not(:first-child),
.subset > :not(:first-child),
.phrase > :not(:first-child) {
  margin-left: 5px;
}

.text-definition.highlighted .operator-label,
.text-definition.highlighted .keyword {
  font-weight: 700;
  color: #7e22ce;
}

.text-definition.highlighted .iriref {
  font-weight: 700;
  color: #2563eb;
}

.text-definition .iriref:hover {
  cursor: pointer;
}
.edit .text-definition .iriref:hover {
  text-decoration: underline;
}

.operator-label {
  min-width: 30px;
}

.operator {
  display: inline-flex;
}

.static {
  display: inline-flex;
}

.iriref {
  display: flex;
  /* margin-left: 10px; */
}

.vertical .selector {
  /* margin-left: 10px; */
}

.property :not(:first-child) {
}

.operator-items {
  display: flex;
  flex-direction: column;
}


.operator-items:first-child {
  margin-left: 20px;
}

</style>
