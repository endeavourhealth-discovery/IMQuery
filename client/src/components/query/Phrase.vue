<template>
  <div :class="'text-definition ' + [highlighted ? 'highlighted' : '']">
    <!-- Templates - add new ones here  -->
    <template v-if="template">
      <template v-if="template == 'IncludeEntity' && valueType == 'TTIriRef'">
        <div class="phrase">
          <div class="keyword">
            {{ "Include" }}
          </div>
          <div>
            {{ a }}
          </div>
          <div class="iriref">
            {{ entity.name }}
          </div>
          <div>{{ "if" }}</div>
          <div>{{ pronoun }}</div>
        </div>
      </template>
      <template v-else-if="template == 'subsetOf' && valueType == 'TTIriRef'">
        <div class="list">
          <div class="">
            {{ "were part of the search results of " }}
          </div>
          <Selector class="iriref" :path="path" :modelValue="entity"></Selector>
        
        </div>
      </template>
    </template>
    <!-- Templates - add new ones here -->

    <!-- For all sentences generated by backend -->
    <div v-else-if="valueType == 'match'" >
      <template v-if="hasKey(entity, 'property')">
        <div :class="'property flex ' + [index > 0 ? ' second' : '']">
          <span :class="'operator-label '"> {{ index > 0 ? operator : "if they" }}</span>
          <Selector :path="path" :modelValue="entity"></Selector>

        </div>
      </template>
      <template v-else>
        <template v-for="(child, childIndex) in children(entity)" :key="child.path">
          <div v-if="child.path == 'subsetOf'" class="inline-flex">
            <div class="operator-label">{{ childIndex > 0 ? operator : "" }}</div>
            <Phrase
              v-for="(grandChild, grandChildIndex) in child.value"
              :object="object"
              :path="`${path}.${child.path}[${grandChildIndex}]`"
              template="subsetOf"
              valueType="TTIriRef"
              :index="grandChildIndex"
            >
            </Phrase>
          </div>
          <div v-else-if="isOperator(child.path)" class="flex">
            <div v-if="operator" class="operator-label">{{ operator }}</div>
            <div class="operator-items">
              <Phrase
                v-for="(grandChild, grandChildIndex) in children(child.value)"
                :object="object"
                :path="`${path}.${child.path}[${grandChildIndex}]`"
                valueType="match"
                :operator="grandChildIndex > 0 ? child.path : ''"
                :index="grandChildIndex"
              >
              </Phrase>
            </div>
          </div>
        </template>
      </template>
    </div>

    <!-- Subphrases -->
    <slot> </slot>
    <!-- Subphrases -->
  </div>
</template>

<script lang="ts">
import { defineComponent } from "vue";
import { Helpers } from "../../models/text/Helpers";

import Selector from "./Selector.vue"
import _ from "lodash";

export default defineComponent({
  name: "Phrase",
  components: {Selector},
  props: ["template", "modelValue", "object", "path", "valueType", "keys", "excludedKeys", "operator", "highlighted", "index"],
  // emits: ["update:modelValue"],
  methods: {
    isOperator(testString: any): boolean {
      return ["and", "or"].includes(testString);
    },
    hasKey(testObjecty: any, comparatorKey: string): boolean {
      return Object.keys(testObjecty).some(key => key == comparatorKey);
    },
    children(testObject: any) {
      console.log("keys", Object.keys(testObject));
      let children = Object.keys(testObject).map((key: string) => {
        const isIncludedKey = ["and", "or", "subsetOf", "property"].includes(key);
        const isExcludedKey = ["entityType"].includes(key);
        const isNumber = typeof parseInt(key) == "number";
        // console.log("hasIncludedKeys", hasIncludedKeys);
        // console.log("hasExcludedKeys", hasExcludedKeys);
        // console.log("parseInt(key)", parseInt(key));
        // console.log("isNumber", isNumber);

        if ((isIncludedKey || isNumber) && !isExcludedKey) {
          return { path: key, value: testObject[key] };
        } else {
          return {};
        }
      });
      children = children.filter(child => child.path);
      return children;
    }
  },
  data() {
    return {
      entity: this.path ? _.get(this.object, this.path) : this.object
    };
  },
  computed: {
    pronoun: {
      get() {
        return Helpers.pronoun(this.entity.name);
      },
      set() {}
    },
    a: {
      get() {
        return Helpers.a(this.entity.name);
      },
      set() {}
    }
  }
});
</script>

<style>
.text-definition,
.text-definition .static {
  font-size: 14px !important;
  font-weight: 400 !important;
  color: #000 !important;
}

.phrase {
  display: inline-flex;
}

.text-definition .list,
.text-definition .subset .subphrases {
  display: inline-flex;
  flex-direction: column;
}

.subphrase {
  display: inline-flex;
}

.subset > :not(:first-child),
.phrase > :not(:first-child) {
  display: flex;
  margin-left: 5px;
}

.text-definition.highlighted .operator-label,
.text-definition.highlighted .keyword {
  font-weight: 700;
  color: #7e22ce;
}

.text-definition.highlighted .iriref {
  font-weight: 700;
  color: #2563eb;
}

.text-definition .iriref:hover {
  text-decoration: underline;
  cursor: pointer;
}

.operator-label {
  min-width: 50px;
}

.operator {
  display: inline-flex;
}

.static {
  display: inline-flex;
}

.iriref {
  display: flex;
  /* margin-left: 10px; */
}

.operator .iriref {
  margin-left: 5px;
}

.property :not(:first-child) {
}

.operator-items {
  display: flex;
  flex-direction: column;
}

/* .operator-items :not(:first-child) { */

.operator-items:first-child {
  margin-left: 50px;
}

.operator-items .property.second {
  margin-left: 50px;
}
</style>
